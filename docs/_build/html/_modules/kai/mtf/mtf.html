<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kai.mtf.mtf &mdash; KAI  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> KAI
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">KAI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>kai.mtf.mtf</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for kai.mtf.mtf</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">mmm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">fftpack</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span>
<span class="kn">from</span> <span class="nn">jlu.util</span> <span class="kn">import</span> <span class="n">radialProfile</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">py</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">nxutils</span>
<span class="kn">from</span> <span class="nn">jlu.util</span> <span class="kn">import</span> <span class="n">mpfit</span>
<span class="kn">import</span> <span class="nn">time</span>

<div class="viewcode-block" id="Fvalues"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.Fvalues">[docs]</a><span class="n">Fvalues</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;wide&#39;</span><span class="p">:</span> <span class="mf">139.9</span><span class="p">,</span> <span class="s1">&#39;narrow&#39;</span><span class="p">:</span> <span class="mf">557.0</span><span class="p">}</span></div>

<div class="viewcode-block" id="get_mtf"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.get_mtf">[docs]</a><span class="k">def</span> <span class="nf">get_mtf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">sources</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    image - 2D numpy array containing the image. Image must be square.</span>
<span class="sd">    params - a dictionary with the various parameters used to calculate</span>
<span class="sd">             the MTF.</span>
<span class="sd">    sources - (def=None) and optional 2D numpy array (same size as image)</span>
<span class="sd">              that contains the distribution of stars in the image as delta</span>
<span class="sd">              functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Some image testing to catch unexpected inputs</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input image must be 2-dimensional&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input image must be square&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sources</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sources</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input sources must be of the same size as image&#39;</span><span class="p">)</span>
            <span class="k">return</span>

    <span class="c1"># Pull out the necessary paramters</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>              <span class="c1"># telescope primary mirror diameter in meters</span>
    <span class="n">wave</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span>        <span class="c1"># observing wavelength in meters</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span>              <span class="c1"># effective focal length at detector in meters</span>
    <span class="n">Apix</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;Apix&#39;</span><span class="p">]</span>        <span class="c1"># pixel size of detector in meters</span>
    <span class="n">platescale</span> <span class="o">=</span> <span class="n">Apix</span> <span class="o">/</span> <span class="n">F</span>        <span class="c1"># plate scale of detector in radians/pixel</span>

    <span class="c1"># Calculate the sky in the image.</span>
    <span class="n">skyInfo</span> <span class="o">=</span> <span class="n">mmm</span><span class="o">.</span><span class="n">mmm</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">skyMode</span> <span class="o">=</span> <span class="n">skyInfo</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span>
    <span class="n">skySigma</span> <span class="o">=</span> <span class="n">skyInfo</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>

    <span class="c1"># Apodize the image with a Hanning kernal to enforce periodicity</span>
    <span class="n">szx</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">szy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">han</span> <span class="o">=</span> <span class="n">hanning</span><span class="p">(</span><span class="n">szx</span><span class="p">,</span> <span class="n">szy</span><span class="p">)</span>
    <span class="n">img_skysub</span> <span class="o">=</span> <span class="n">image</span> <span class="o">-</span> <span class="n">skyMode</span>

    <span class="n">fftim</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">img_skysub</span> <span class="o">*</span> <span class="n">han</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">szx</span> <span class="o">*</span> <span class="n">szy</span><span class="p">)</span>
    <span class="n">absim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">fftim</span> <span class="o">*</span> <span class="n">fftim</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="p">)</span>
    <span class="n">absim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>   <span class="c1"># don&#39;t count the DC component</span>
    <span class="n">wrapim</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span> <span class="n">absim</span> <span class="p">)</span>  <span class="c1"># this is the 2D power spectrum</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">wrapim</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span> <span class="p">)</span>
    <span class="n">xcen</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ycen</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">radialProfile</span><span class="o">.</span><span class="n">azimuthalAverage</span><span class="p">(</span><span class="n">wrapim</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="n">xcen</span><span class="p">,</span><span class="n">ycen</span><span class="p">],</span> 
                                         <span class="n">ignoreNAN</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pix</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">rms</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">cut_d</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">platescale</span>   <span class="c1"># detector minimum angle in radians</span>
    <span class="n">cut_t</span> <span class="o">=</span> <span class="n">wave</span> <span class="o">/</span> <span class="n">D</span>           <span class="c1"># telescope minimum angle in radians</span>
    <span class="n">rat</span> <span class="o">=</span> <span class="n">cut_d</span> <span class="o">/</span> <span class="n">cut_t</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">szx</span> <span class="o">*</span> <span class="n">rat</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">rms</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span>

    <span class="c1"># Ignore frequencies higher than the critical frequency</span>
    <span class="n">keepind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="n">keepind</span><span class="p">]</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">keepind</span><span class="p">]</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="n">keepind</span><span class="p">]</span>

    <span class="n">pspec_sources_2d</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">sources</span> <span class="o">*</span> <span class="n">han</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">szx</span> <span class="o">*</span> <span class="n">szy</span><span class="p">)</span>
    <span class="n">pspec_sources_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pspec_sources_2d</span> <span class="o">*</span> <span class="n">pspec_sources_2d</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
    <span class="n">pspec_sources_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">pspec_sources_2d</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span> <span class="n">pspec_sources_2d</span> <span class="p">)</span>
    
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">radialProfile</span><span class="o">.</span><span class="n">azimuthalAverage</span><span class="p">(</span><span class="n">pspec_sources_2d</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="n">xcen</span><span class="p">,</span> <span class="n">ycen</span><span class="p">],</span>
                                         <span class="n">ignoreNAN</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">pspec_freq</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pspec_sources</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">pspec_sources</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">pspec_sources</span><span class="p">)</span>
    <span class="n">pspec_sources</span> <span class="o">=</span> <span class="n">pspec_sources</span><span class="p">[</span><span class="n">keepind</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">pspec_sources</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="hanning"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.hanning">[docs]</a><span class="k">def</span> <span class="nf">hanning</span><span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a 2D hanning kernel from the seperable 1D hanning kernels. The</span>
<span class="sd">    default kernel peaks at 1 at the center and falls to zero at the edges.</span>
<span class="sd">    Use invert=True to make an inner mask that is 0 at the center and rises</span>
<span class="sd">    to 1 at the edges.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask1D_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">xsize</span><span class="p">)</span>
    <span class="n">mask1D_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">ysize</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">mask1D_x</span><span class="p">,</span> <span class="n">mask1D_y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">mask</span> <span class="o">+</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">mask</span></div>

    

<div class="viewcode-block" id="mtffunc_keck"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.mtffunc_keck">[docs]</a><span class="k">def</span> <span class="nf">mtffunc_keck</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Apix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">pupil</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tperf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">output</span><span class="o">=</span><span class="s1">&#39;system&#39;</span><span class="p">,</span> <span class="n">fjac</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            MTFFUNC_KECK</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Given the appropriate input parameters, returns the</span>
<span class="sd">            square of the 1-D Modulation Transfer Function (MTF)^2 of</span>
<span class="sd">            an optical system consisting of a </span>
<span class="sd">            telescope + detector + atmosphere + Adaptive Optics (AO) system.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            How should I know?</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            RESULT=MTFFUNC_KECK(NU, PARAMS, [/PERF, /ATMOS_AO, $</span>
<span class="sd">                                SPDIST=SPDIST])</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            NU:   The spatial frequencies at which the MTF will be</span>
<span class="sd">            computed, in normalized units (i.e. nu=1 at spatial frequency</span>
<span class="sd">            D/lambda for a circular aperture telescope), and need not be</span>
<span class="sd">            regularly gridded.</span>
<span class="sd">    </span>
<span class="sd">            PARAMS:   A structure of parameters defined as follows:</span>
<span class="sd">    </span>
<span class="sd">                      params.lambda  - wavelength in meters of the</span>
<span class="sd">                                       observation </span>
<span class="sd">                      params.f       - effective focal length at detector</span>
<span class="sd">                                       in meters</span>
<span class="sd">                      params.D       - telescope pupil diameter in meters,</span>
<span class="sd">                                       defining the normalized spatial</span>
<span class="sd">                                       frequency NU which is in units of</span>
<span class="sd">                                       D/lambda; not necessarily 10</span>
<span class="sd">                                       meters for Keck! (see PROCEDURE</span>
<span class="sd">                                       below)   </span>
<span class="sd">                      params.A       - width of detector pixel in meters,</span>
<span class="sd">                                       27 microns for the NIRC2 narrow</span>
<span class="sd">                                       field.</span>
<span class="sd">                      params.pupil   - a string equal to the name of</span>
<span class="sd">                                       the pupil-stop of the NIRC2</span>
<span class="sd">                                       camera (see documentation for</span>
<span class="sd">                                       T_PERFECT_KECK for a list of</span>
<span class="sd">                                       available pupil-stop names) or for</span>
<span class="sd">                                       a circular pupil, the scalar</span>
<span class="sd">                                       floating point value of the</span>
<span class="sd">                                       pupil&#39;s central obscuration.  The</span>
<span class="sd">                                       data type of this parameter</span>
<span class="sd">                                       deterimines the form of the pupil</span>
<span class="sd">                                       MTF used (see PROCEDURE below).</span>
<span class="sd">                      params.L0      - the outer scale of turbluence, in</span>
<span class="sd">                                       meters, for a modified Kolmogorov</span>
<span class="sd">                                       spectrum</span>
<span class="sd">                      params.sigma   - the width of the AO system</span>
<span class="sd">                                       deformable mirror&#39;s (DM&#39;s)</span>
<span class="sd">                                       influence function as projected</span>
<span class="sd">                                       onto the pupil plane, in meters.</span>
<span class="sd">                      params.w       - scaling factor for the influence</span>
<span class="sd">                                       function&#39;s Fourier transform;</span>
<span class="sd">                                       mimics variable AO correction (see</span>
<span class="sd">                                       documentation for</span>
<span class="sd">                                       FT_INFL_FUNCTION) </span>
<span class="sd">                      params.delta   - wavefront measurement error</span>
<span class="sd">                      params.cmult   - constant scaling factor of the output</span>
<span class="sd">                                       MTF</span>
<span class="sd">                      params.N       - additive constant to output MTF</span>
<span class="sd">                                       representing a noise floor</span>
<span class="sd">                      params.r0      - wavelength specific Fried</span>
<span class="sd">                                       parameter in meters (see PROCEDURE</span>
<span class="sd">                                       below). </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            SPDIST: Set this keyword to a vector the same size as nu, the</span>
<span class="sd">                    1-D power spectrum of the source distribution power</span>
<span class="sd">                    spectrum of an image for which you wish to fit an</span>
<span class="sd">                    MTF.  The output (MTF)^2 is multiplied by this vector</span>
<span class="sd">                    before output.</span>
<span class="sd">            /PERF:  If this keyword is set, RESULT is the square of the</span>
<span class="sd">                    diffraction limited pupil MTF. </span>
<span class="sd">            /ATMOS_AO:   If this keyword is set, RESULT is the square of</span>
<span class="sd">                    the AO filtered atmospheric MTF.</span>
<span class="sd">            /PIX    Returns the MTF^2 of an ideal pixel.</span>
<span class="sd">            _EXTRA: Use this keyword to pass in a structure containing</span>
<span class="sd">                    constant parameters that need not be recomputed each</span>
<span class="sd">                    time MTFFUNC_KECK is called.  This is useful for</span>
<span class="sd">                    speeding up an iterative fitting procedure that uses</span>
<span class="sd">                    MTFFUNC_KECK.  The structure passed in via this</span>
<span class="sd">                    keyword must contain the following parameters/tags:</span>
<span class="sd">    </span>
<span class="sd">                     _EXTRA = {lambda:lambda, f:f, D:D, pupil:pupil, $</span>
<span class="sd">                               A:A, TPERF:TPERF, SPDIST:SPDIST}</span>
<span class="sd">    </span>
<span class="sd">                    where lambda, f, D, A, and pupil are definted exactly</span>
<span class="sd">                    as they are for input via PARAMS; TPERF is a vector</span>
<span class="sd">                    of size equal to NU and is the diffraction limited</span>
<span class="sd">                    pupil MTF (N.B., not the squared MTF) and is</span>
<span class="sd">                    equivalent to the square root of the output of</span>
<span class="sd">                    MTFFUNC_KECK with the /PERF keyword set; SPDIST is</span>
<span class="sd">                    the power spectrum of and image&#39;s source distribution</span>
<span class="sd">                    function, identical to SPDIST.  </span>

<span class="sd">                    If the keyword _EXTRA is set to this structure,</span>
<span class="sd">                    then PARAMS must not be a structure containing all of</span>
<span class="sd">                    the parameters defined in PARAMS above, but must be a</span>
<span class="sd">                    7 element vector defined as such:</span>
<span class="sd">    </span>
<span class="sd">                    PARAMS[0] = L0, PARAMS[1] = sigma, PARAMS[2] = w,</span>
<span class="sd">                     PARAMS[3] = delta, PARAMS[4] = cmult, PARAMS[5]= N,</span>
<span class="sd">                      PARAMS[6] = r0.</span>
<span class="sd">    </span>
<span class="sd">                    Setting the keyword SPDIST</span>
<span class="sd">                    overrides the source distribution power spectrum</span>
<span class="sd">                    passed in via the _EXTRA keyword.  If the _EXTRA</span>
<span class="sd">                    keyword is not set and a structure of parameters is</span>
<span class="sd">                    passed in via PARAMS, then SPDIST is the only way to</span>
<span class="sd">                    multiply the output of MTFFUNC_KECK by a vector</span>
<span class="sd">                    before returning.</span>
<span class="sd">                     </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            RESULT:  The (MTF)^2, evaluated at the input spatial</span>
<span class="sd">            frequencies, NU.</span>
<span class="sd">    </span>
<span class="sd">     RESTRICTIONS:</span>
<span class="sd">            NU must be greater than zero.  </span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE CALLS:</span>
<span class="sd">            T_ATMOS_AO(), T_PIX(), T_PERFECT_KECK(), T_PERFECT()</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE:</span>
<span class="sd">            If PARAMS.pupil is a string, it must specify the pupil stop</span>
<span class="sd">            name of the NIRC2 camera that was in place at the time of the</span>
<span class="sd">            observation.  See the documentation for NIRC2PUPIL for a list</span>
<span class="sd">            of acceptable pupil stop names.  In this case, the pupil MTF</span>
<span class="sd">            is numerically calculated as the autocorrelation function of</span>
<span class="sd">            the Keck pupil via the procedure T_PERFECT_KECK.</span>
<span class="sd">    </span>
<span class="sd">            If PARAMS.pupil is a floating point scalar, the pupil MTF is</span>
<span class="sd">            calculated analytically via the procedure T_PERFECT for a</span>
<span class="sd">            circular pupil with central obscuration PARAMS.pupil.  (See</span>
<span class="sd">            the documentation for T_PERFECT.)  This functionality is not</span>
<span class="sd">            intended for use with Keck AO data, but is included in the</span>
<span class="sd">            event this software is applied to data from other AO systems,</span>
<span class="sd">            such as the Lick 3-meter telescope.</span>
<span class="sd">            </span>
<span class="sd">            PARAMS.delta is untested, and for the time being should be</span>
<span class="sd">            left set to zero.</span>
<span class="sd">    </span>
<span class="sd">            In general PARAMS.D should not be set to the familiar 10</span>
<span class="sd">            meters, which is the effective diameter of the Keck pupil.</span>
<span class="sd">            Since this parameter defines the maximum spatial frequency</span>
<span class="sd">            D/lambda to which the telescope is sensitive, it should be</span>
<span class="sd">            equal to the diameter of the circle inscribing the Keck</span>
<span class="sd">            pupil.  This is because the lambda/D minimum angle changes</span>
<span class="sd">            depending on orientation in the image plane, and in certain</span>
<span class="sd">            orientations the diameter appropriate for this specification</span>
<span class="sd">            is D = 10.99 m.</span>
<span class="sd">    </span>
<span class="sd">            r0 is the wavelength specific Fried parameter.  Generally,</span>
<span class="sd">            the r0 specifying seeing conditions is quoted for a</span>
<span class="sd">            wavelength of 500 nm.  If one has reason to believe that the</span>
<span class="sd">            r0 for a set of observations is 20 cm, then the wavelength</span>
<span class="sd">            specific r0 is given as</span>
<span class="sd">                r0_lambda = r0 * (lambda/500 nm)^(6/5)</span>
<span class="sd">            and this is the r0 that should be specified in PARAMS.RO.</span>
<span class="sd">    </span>
<span class="sd">            The effective focal length at the detector, PARAMS.F, is</span>
<span class="sd">            related to the platescale of the detector by</span>
<span class="sd">                F = Apix / platescale</span>
<span class="sd">            where platescale is in radians / pixel.  If the platescale</span>
<span class="sd">            and the pixel size is accurately known, F should be</span>
<span class="sd">            calculated in this manner.</span>
<span class="sd">     </span>
<span class="sd">     EXAMPLE:</span>
<span class="sd">            Generate a model MTF for an H-band NIRC2 image at the .01</span>
<span class="sd">            arcsec/pixel platescale at normalized spatial fequencies in</span>
<span class="sd">            the image plane from 0 to 1:</span>
<span class="sd">            </span>
<span class="sd">            params={lambda:1.6e-6, F:557.0, D:10.99,  $</span>
<span class="sd">                    L0:30.0, sigma:0.56, w:1.5, delta:0.0, cmult:1.0, $</span>
<span class="sd">                    N:1e-4, r0:0.65, Apix:27e-6, pupil:&#39;largehex&#39;}</span>
<span class="sd">            nu = findgen(100)/99.</span>
<span class="sd">            tsys_squared = mtffunc_keck(nu,params) </span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by:  Christopher D. Sheehy, January 2006.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input NU cannot be less than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">wave</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;wave&#39;</span><span class="p">:</span> <span class="n">wave</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="n">F</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="n">D</span><span class="p">,</span> <span class="s1">&#39;Apix&#39;</span><span class="p">:</span> <span class="n">Apix</span><span class="p">,</span> <span class="s1">&#39;pupil&#39;</span><span class="p">:</span> <span class="n">pupil</span><span class="p">}</span>
        <span class="n">p</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">params_arr2dict</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="p">)</span>

        <span class="n">MTF_perf</span> <span class="o">=</span> <span class="n">tperf</span>
        <span class="n">spdist_mult</span> <span class="o">=</span> <span class="n">sources</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">pp</span>
        <span class="n">spdist_mult</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;pupil&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">MTF_perf</span> <span class="o">=</span> <span class="n">t_perfect_keck</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pupil</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;pupil&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">MTF_perf</span> <span class="o">=</span> <span class="n">t_perfect</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;pupil&#39;</span><span class="p">])</span>
            
    <span class="k">if</span> <span class="n">sources</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spdist_mult</span> <span class="o">=</span> <span class="n">sources</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spdist_mult</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">MTF_atmos_ao</span> <span class="o">=</span> <span class="n">t_atmos_ao</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">MTF_pix</span> <span class="o">=</span> <span class="n">t_pix</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">tsys</span> <span class="o">=</span> <span class="n">MTF_perf</span> <span class="o">*</span> <span class="n">MTF_atmos_ao</span> <span class="o">*</span> <span class="n">MTF_pix</span>
    <span class="n">MTF_sys2</span> <span class="o">=</span> <span class="p">(</span><span class="n">spdist_mult</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;cmult&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">tsys</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span>

    <span class="c1"># We have several output options:</span>
    <span class="n">all_mtfs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">all_mtfs</span><span class="p">[</span><span class="s1">&#39;perfect&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MTF_perf</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">all_mtfs</span><span class="p">[</span><span class="s1">&#39;atmos_ao&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MTF_atmos_ao</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">all_mtfs</span><span class="p">[</span><span class="s1">&#39;pixel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MTF_pix</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">all_mtfs</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MTF_sys2</span>
    
    <span class="k">return</span> <span class="n">all_mtfs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span></div>
    

<div class="viewcode-block" id="fitmtf_keck"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.fitmtf_keck">[docs]</a><span class="k">def</span> <span class="nf">fitmtf_keck</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">pspec_sources</span><span class="p">,</span> 
                <span class="n">clip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">startParams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relStep</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NAME:</span>
<span class="sd">         FITMTF_KECK</span>
<span class="sd">    </span>
<span class="sd">    PURPOSE:</span>
<span class="sd">         Uses MPFIT to perform a constrained Levenberg-Markwardt fit of</span>
<span class="sd">         a model MTF to data from a Keck adaptive optics image.  It is</span>
<span class="sd">         highly recommended that the user edit this procedure to suit</span>
<span class="sd">         his or her particular needs, i.e. changing the default initial</span>
<span class="sd">         guesses for the fit parameters and the step size to MPFIT.</span>
<span class="sd">    </span>
<span class="sd">         This procedure is meant as a guide to illustrate how to use</span>
<span class="sd">         MPFIT in conjunction with the AO MTF software.  Just because</span>
<span class="sd">         MPFIT returns best fit parameters does not mean that it has</span>
<span class="sd">         found an absolute minimum in Chi-squared.  As with most</span>
<span class="sd">         non-linear fit routines, some tinkering may be required to</span>
<span class="sd">         avoid local minima and to obtain accurate fits.  In other</span>
<span class="sd">         words, this procedure should not be applied blindly.</span>
<span class="sd">    </span>
<span class="sd">         In general, a good way to obtain accurate fits is to first</span>
<span class="sd">         perform the fits with decent starting guesses for the fit</span>
<span class="sd">         parameters and specifying a relatively large step size over</span>
<span class="sd">         which MPFIT calculates the numerical derivative of the fit</span>
<span class="sd">         function w.r.t. the fit parameters.  Once the best fit</span>
<span class="sd">         parameters are obtained from this iteration, the step</span>
<span class="sd">         size can be decreased and the best fit parameters from the</span>
<span class="sd">         first iteration should be used as the starting guesses for the</span>
<span class="sd">         parameters in the second iteration.  </span>
<span class="sd">    </span>
<span class="sd">         A good rule of thumb that seems to work in some (many?) cases</span>
<span class="sd">         is specifying the step size in the first iteration to be 20% of the</span>
<span class="sd">         parameters&#39; respective values, and a step size of 2% in the</span>
<span class="sd">         second interation.  This can be accomplished by changing the</span>
<span class="sd">         values of PARINFO[*].relstep from 0.20 to 0.02 within the</span>
<span class="sd">         procedure or via the RELSTEP keyword defined at the main</span>
<span class="sd">         level. Different step sizes for different parameters can be</span>
<span class="sd">         specified by editing PARINFO[*].relstep within the procedure.</span>
<span class="sd">    </span>
<span class="sd">    CATEGORY:</span>
<span class="sd">         ???</span>
<span class="sd">    </span>
<span class="sd">    CALLING SEQUENCE:</span>
<span class="sd">         FITMTF_KECK, filename, params, perror, covar, chisq, $</span>
<span class="sd">                      [start=start, relstep=relstep, quiet=quiet]</span>
<span class="sd">    </span>
<span class="sd">    INPUTS:</span>
<span class="sd">         FILENAME: A scalar string specifying the filename of an IDL</span>
<span class="sd">                   save file containing the data to which the model MTF</span>
<span class="sd">                   is fit.  The command</span>
<span class="sd">                         restore, FILENAME</span>
<span class="sd">                   must restore the variables NU, POWER, ERROR, and</span>
<span class="sd">                   SPDIST, which are vectors of equal size.  These</span>
<span class="sd">                   variables are the outputs of the routine GETMTF.</span>
<span class="sd">    </span>
<span class="sd">    KEYWORD PARAMETERS:</span>
<span class="sd">         START:   Set this keyword equal to a structure containing</span>
<span class="sd">                  starting guesses for the fit parameters as defined in</span>
<span class="sd">                  the documentation for MTFFUNC_KECK.  If not set, they</span>
<span class="sd">                  the default values must be defined within the</span>
<span class="sd">                  procedure.  </span>
<span class="sd">    </span>
<span class="sd">         CLIP:    Set this keyword equal to a scalar value defining the</span>
<span class="sd">                  normalized spatial frequency (defined by NU) below</span>
<span class="sd">                  which the data restored from FILENAME will be ignored.</span>
<span class="sd">                  By default, this value is None (no clipping).  </span>
<span class="sd">                  Setting CLIP = 0.0 fits all of the data.  </span>
<span class="sd">                  However, this is generally not</span>
<span class="sd">                  recommended because imperfect sky subtraction of the</span>
<span class="sd">                  image from which NU and POWER were computed usually</span>
<span class="sd">                  contaminates the power spectrum at low spatial</span>
<span class="sd">                  frequencies. The recommended value is 0.02.</span>
<span class="sd">    </span>
<span class="sd">         RELSTEP: Defines the relative step size over which MPFIT</span>
<span class="sd">                  computes the numerical derivative of Chi-sqared</span>
<span class="sd">                  w.r.t. the fit parameters.  Sets the value</span>
<span class="sd">                  PARINFO[*].relstep, which is an input to MPFIT (see</span>
<span class="sd">                  the documentation for MPFIT).</span>
<span class="sd">      </span>
<span class="sd">         /QUIET : Set this keyword to supress the printed output of</span>
<span class="sd">                  MPFIT.  Generally, though, it is good practice to keep</span>
<span class="sd">                  tabs on what MPFIT is doing as it&#39;s proceding with the</span>
<span class="sd">                  fit.  </span>
<span class="sd">    </span>
<span class="sd">    OUTPUTS:</span>
<span class="sd">         PARAMS:  A structure of the best fit parameters as determined</span>
<span class="sd">                  by MPFIT; can be used as the input parameters to</span>
<span class="sd">                  MTFFUNC_KECK, MTF2PSF, MTF2EE, or any of</span>
<span class="sd">                  MTFFUNC_KECK&#39;s subsidiary routines.  </span>
<span class="sd">    </span>
<span class="sd">                  The parameters that are fit are L0, sigma, w,</span>
<span class="sd">                  delta, cmult, N, and r0.  The rest are only supplied</span>
<span class="sd">                  as information to MTFFUNC_KECK.  In addition, some of</span>
<span class="sd">                  these fit parameters may be held constant if they are</span>
<span class="sd">                  known or assumed (SIMGA and DELTA are held fixed by </span>
<span class="sd">                  default when performing the fit).  Constant parameters</span>
<span class="sd">                  are specified by setting PARINFO[i].fixed to 1 within</span>
<span class="sd">                  the FITMTF_KECK procedure (see documentation for</span>
<span class="sd">                  MPFIT and MPFITFUN).</span>
<span class="sd">    </span>
<span class="sd">         PERROR:  A structure of formal error in the best fit</span>
<span class="sd">                  parameters, as determined by MPFIT.  Parameters that</span>
<span class="sd">                  are not included in the fit or are held fixed during</span>
<span class="sd">                  the fit return an error of 0.</span>
<span class="sd">    </span>
<span class="sd">         COVAR:   The parameter covariance matrix, of size N x N, where</span>
<span class="sd">                  N is the number of fit parameters supplied to MPFIT,</span>
<span class="sd">                  the values of which depend on the order of the vector</span>
<span class="sd">                  of input parameters supplied to MPFIT.  (See</span>
<span class="sd">                  documentation for MPFIT and order of FCNARGS as</span>
<span class="sd">                  defined within this procedure.)</span>
<span class="sd">    </span>
<span class="sd">         CHISQ:   The quantity (RESIDS/ERROR)^2, where </span>
<span class="sd">                  RESIDS = POWER - BESTFIT, and POWER and ERROR are</span>
<span class="sd">                  the vectors restored from FILENAME (see above).</span>
<span class="sd">                  CHISQ is calculated ignoring data at NU &lt; CLIP. </span>
<span class="sd">    </span>
<span class="sd">         NITER:   Number of iterations performed by the fitting routine.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    PROCEDURE CALLS:</span>
<span class="sd">         MPFITFUN, MPFIT, T_PERFECT_KECK</span>
<span class="sd">    </span>
<span class="sd">    EXAMPLE:</span>
<span class="sd">         read in a fully reduced H-band NIRC2 image</span>
<span class="sd">         im = READFITS(&#39;myimage.fits&#39;)  </span>
<span class="sd">        </span>
<span class="sd">         calculate its power spectrum</span>
<span class="sd">         p = {lambda:1.65e-6, D:10.99, F:557.0, APIX:27e-6}</span>
<span class="sd">         GETMTF, im, p, nu, power, error, spdist</span>
<span class="sd">         SAVE, nu, power, error, spdist, filename=&#39;mtfdata.sav&#39;</span>
<span class="sd">    </span>
<span class="sd">         fit an MTF to this data</span>
<span class="sd">         startp = {wave:1.65e-6, D:10.99, F:557.0, Apix:27e-6, $</span>
<span class="sd">                   pupil:&#39;largehex&#39;, L0:30.0, sigma:0.56, $</span>
<span class="sd">                   w:1.3, delta:0.0, cmult:1.0, N:1e-5, r0:0.5}</span>
<span class="sd">         FITMTF_KECK, &#39;mtfdata.sav&#39;, bestfit_params, start=startp</span>
<span class="sd">    </span>
<span class="sd">         zero in on the best fit parameters by editing FITMTF_KECK to</span>
<span class="sd">         perform the fit using a smaller step size to MPFIT.  Change</span>
<span class="sd">         PARINFO[*].relstep from 0.20 to 0.02, recomplie FITMTF_KECK,</span>
<span class="sd">         and perform the fit again using the previous best fit</span>
<span class="sd">         parameters as the new starting parameters.</span>
<span class="sd">         FITMTF_KECK, &#39;mtfdata.sav&#39;, bestfit_params2, start=bestfit_params</span>
<span class="sd">    </span>
<span class="sd">         calculate the encircled energy for the PSF in image</span>
<span class="sd">         &#39;myimage.fits&#39; at a radius of 25 pixels (at the 0.01 arcsec/pix</span>
<span class="sd">         NIRC2 platescale). </span>
<span class="sd">         MTF2EE, bestfit_params2, 25.0, EE</span>
<span class="sd">         print, EE</span>
<span class="sd">    </span>
<span class="sd">         compute the best fit power spectrum</span>
<span class="sd">         PSPEC = MTFFUNC_KECK(nu, bestfit_params2, spdist=spdist)</span>
<span class="sd">         plot, nu, power, /ylog, psym=4</span>
<span class="sd">         oplot, nu, pspec</span>
<span class="sd">    </span>
<span class="sd">         plot the best fit MTF</span>
<span class="sd">         T = sqrt(MTFFUNC_KECK(nu, bestfit_params2)</span>
<span class="sd">         plot, nu, T, /ylog</span>
<span class="sd">    </span>
<span class="sd">    MODIFICATION HISTORY:</span>
<span class="sd">         Written by Christopher D. Sheehy, January 2006.</span>
<span class="sd">         Added &quot;niter&quot; keyword, Nate McCrady, May 17, 2007.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">clip</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nu</span> <span class="o">&lt;=</span> <span class="n">clip</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">xx</span> <span class="o">=</span> <span class="n">nu</span><span class="p">[</span><span class="n">lo</span><span class="p">:]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">power</span><span class="p">[</span><span class="n">lo</span><span class="p">:]</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">error</span><span class="p">[</span><span class="n">lo</span><span class="p">:]</span>
    <span class="c1">#err = power[lo:] * 0.01   # uniform 1 percent error for a test??</span>
    <span class="n">spdist</span> <span class="o">=</span> <span class="n">pspec_sources</span><span class="p">[</span><span class="n">lo</span><span class="p">:]</span>

    <span class="c1"># Define starting guesses for parameters</span>
    <span class="k">if</span> <span class="n">startParams</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="mf">1.65e-6</span>       <span class="c1"># wavelength in meters</span>
        <span class="n">F</span> <span class="o">=</span> <span class="mf">557.0</span>            <span class="c1"># effective focal length in meters</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Using effective focal length for the narrow camera.&#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="mf">10.99</span>            <span class="c1"># primary mirror diamter in meters</span>
        <span class="n">pupil</span> <span class="o">=</span> <span class="s1">&#39;largehex&#39;</span>   <span class="c1"># NIRC2 pupil-stop</span>
        <span class="n">Apix</span> <span class="o">=</span> <span class="mf">27e-6</span>         <span class="c1"># width of detector&#39;s pixel in meters</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="mf">20.0</span>            <span class="c1"># outer scale of turbulence in meters</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.56</span>         <span class="c1"># IF width on primary in meters</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mf">1.3</span>              <span class="c1"># IF height</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c1"># wavefront measurement error</span>
        <span class="n">cmult</span> <span class="o">=</span> <span class="mf">10.0</span>         <span class="c1"># multiplicative constant</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mf">1e-5</span>             <span class="c1"># additive noise floor constant</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="mf">0.5</span>             <span class="c1"># wavelength specific Fried parameter in meters</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wave</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
        <span class="n">pupil</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;pupil&#39;</span><span class="p">]</span>
        <span class="n">Apix</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;Apix&#39;</span><span class="p">]</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;L0&#39;</span><span class="p">]</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
        <span class="n">cmult</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;cmult&#39;</span><span class="p">]</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="n">startParams</span><span class="p">[</span><span class="s1">&#39;r0&#39;</span><span class="p">]</span>
        
    <span class="c1"># Declare the structure to pass parameters to mpfit</span>
    <span class="n">parinfo</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;fixed&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;limited&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;limits&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
               <span class="s1">&#39;relstep&#39;</span><span class="p">:</span> <span class="n">relStep</span><span class="p">,</span> <span class="s1">&#39;parname&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">}</span>
    <span class="n">pinfo</span> <span class="o">=</span> <span class="p">[</span><span class="n">parinfo</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>

    <span class="c1"># additive constant for model MTF    </span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;parname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;N&#39;</span>    
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>

    <span class="c1"># Fried parameter in meters</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;parname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;r_0&#39;</span>   
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r0</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;limits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>

    <span class="c1"># multiplicative constant for model MTF</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;parname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cmult&#39;</span> 
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmult</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;limited&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;limits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># w of influence func&#39;s 1st gaussian</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="s1">&#39;parname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>      
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="s1">&#39;limited&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="s1">&#39;limits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.01</span><span class="p">]</span>

    <span class="c1"># outer turbulence scale, L_0, in meters</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="s1">&#39;parname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;L0&#39;</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L0</span>   
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="s1">&#39;fixed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="s1">&#39;limited&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="s1">&#39;limits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">3500.</span><span class="p">]</span>

    <span class="c1"># sigma of influ. func&#39;s 1st gaussian (meters)</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="s1">&#39;parname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;sigma&#39;</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="s1">&#39;fixed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># additive noise factor</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="s1">&#39;parname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;delta&#39;</span>  
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="s1">&#39;fixed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="s1">&#39;limited&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">pinfo</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="s1">&#39;limits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">startp</span> <span class="o">=</span> <span class="p">[</span><span class="n">pinfo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pinfo</span><span class="p">))]</span>
        
    <span class="c1"># Pass in constant parameters using the keyword functargs</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pupil</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># This is a keck NIRC2 pupil string</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">t_perfect_keck</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">pupil</span><span class="o">=</span><span class="n">pupil</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise assume no specific telescope and pupil </span>
        <span class="c1"># is just a secondary obscuration.</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">t_perfect</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">pupil</span><span class="p">)</span>

    <span class="n">fcnargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nu&#39;</span><span class="p">:</span> <span class="n">xx</span><span class="p">,</span> <span class="s1">&#39;obs&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">err</span><span class="p">,</span>
               <span class="s1">&#39;wave&#39;</span><span class="p">:</span> <span class="n">wave</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="n">F</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="n">D</span><span class="p">,</span> <span class="s1">&#39;Apix&#39;</span><span class="p">:</span> <span class="n">Apix</span><span class="p">,</span> 
               <span class="s1">&#39;pupil&#39;</span><span class="p">:</span> <span class="n">pupil</span><span class="p">,</span> <span class="s1">&#39;tperf&#39;</span><span class="p">:</span> <span class="n">tp</span><span class="p">,</span> <span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="n">spdist</span><span class="p">,</span>
               <span class="p">}</span>
    
    <span class="c1"># Call the fitting routine MPFIT, passing it the function that returns</span>
    <span class="c1"># the MTF**2 at spatial frequency XX for given input parameters defined</span>
    <span class="c1"># in PARINFO and other information required to generate the MTF</span>
    <span class="c1"># supplied in FCNARGS.</span>

    <span class="c1"># changed 3/18/08 to fit the log of the data</span>

    <span class="k">def</span> <span class="nf">residuals</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                  <span class="n">wave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Apix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                  <span class="n">pupil</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tperf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                  <span class="n">fjac</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">mtffunc_keck</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="n">nu</span><span class="p">,</span> <span class="n">wave</span><span class="o">=</span><span class="n">wave</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">Apix</span><span class="o">=</span><span class="n">Apix</span><span class="p">,</span>
                           <span class="n">pupil</span><span class="o">=</span><span class="n">pupil</span><span class="p">,</span> <span class="n">tperf</span><span class="o">=</span><span class="n">tperf</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="n">sources</span><span class="p">,</span>
                           <span class="n">output</span><span class="o">=</span><span class="s1">&#39;system&#39;</span><span class="p">,</span> <span class="n">fjac</span><span class="o">=</span><span class="n">fjac</span><span class="p">)</span>

        <span class="c1"># Check for appropriate error weighting. Otherwise, simply unweighted.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fit</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="c1">#res = (obs - fit) / err</span>
        
        <span class="n">param_dict</span> <span class="o">=</span> <span class="n">params_arr2dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">paramStr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">paramStr</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%.2g</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="n">py</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">py</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Observed&#39;</span><span class="p">)</span>
        <span class="n">py</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">fit</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Fit&#39;</span><span class="p">)</span>
        <span class="n">py</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">py</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">paramStr</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">py</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Start Fitting: &#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">mpfit</span><span class="o">.</span><span class="n">mpfit</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">startp</span><span class="p">,</span> <span class="n">nprint</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">parinfo</span><span class="o">=</span><span class="n">pinfo</span><span class="p">,</span> <span class="n">functkw</span><span class="o">=</span><span class="n">fcnargs</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Stop Fitting: &#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span>

    <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcnargs</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcnargs</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcnargs</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;Apix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcnargs</span><span class="p">[</span><span class="s1">&#39;Apix&#39;</span><span class="p">]</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;pupil&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcnargs</span><span class="p">[</span><span class="s1">&#39;pupil&#39;</span><span class="p">]</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">params_arr2dict</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">perror</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">perror</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">perror</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">perror</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">perror</span><span class="p">[</span><span class="s1">&#39;Apix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">perror</span><span class="p">[</span><span class="s1">&#39;pupil&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">perror</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params_arr2dict</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">perror</span><span class="p">))</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="n">DataHolder</span><span class="p">()</span>
    <span class="n">output</span><span class="o">.</span><span class="n">obs_nu</span> <span class="o">=</span> <span class="n">nu</span>
    <span class="n">output</span><span class="o">.</span><span class="n">obs_data</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">output</span><span class="o">.</span><span class="n">obs_error</span> <span class="o">=</span> <span class="n">err</span>
    <span class="n">output</span><span class="o">.</span><span class="n">obs_sources</span> <span class="o">=</span> <span class="n">spdist</span>
    <span class="n">output</span><span class="o">.</span><span class="n">tperf</span> <span class="o">=</span> <span class="n">tp</span>
    <span class="n">output</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
    <span class="n">output</span><span class="o">.</span><span class="n">perror</span> <span class="o">=</span> <span class="n">perror</span>
    <span class="n">output</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">params</span>
    <span class="n">output</span><span class="o">.</span><span class="n">fit_covar</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">covar</span>
    <span class="n">output</span><span class="o">.</span><span class="n">fit_stat</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">fnorm</span>

    <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="params_arr2dict"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.params_arr2dict">[docs]</a><span class="k">def</span> <span class="nf">params_arr2dict</span><span class="p">(</span><span class="n">param_array</span><span class="p">):</span>
    <span class="n">param_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;r0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;cmult&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_array</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;L0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_array</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_array</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">param_dict</span></div>
    
<div class="viewcode-block" id="params_dict2arr"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.params_dict2arr">[docs]</a><span class="k">def</span> <span class="nf">params_dict2arr</span><span class="p">(</span><span class="n">param_dict</span><span class="p">):</span>
    <span class="n">param_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">param_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span>
    <span class="n">param_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;r0&#39;</span><span class="p">]</span>
    <span class="n">param_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;cmult&#39;</span><span class="p">]</span>
    <span class="n">param_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span>
    <span class="n">param_arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;L0&#39;</span><span class="p">]</span>
    <span class="n">param_arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
    <span class="n">param_arr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">param_arr</span></div>
    

<div class="viewcode-block" id="t_perfect_keck"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.t_perfect_keck">[docs]</a><span class="k">def</span> <span class="nf">t_perfect_keck</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pupil</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NAME:</span>
<span class="sd">           T_PERFECT_KECK</span>
<span class="sd">    </span>
<span class="sd">    PURPOSE:</span>
<span class="sd">           Numerically computes a 1-D approximation to the 2-D</span>
<span class="sd">           diffraction limited MTF of the segmented Keck pupil,</span>
<span class="sd">           appropriate for the NIRC2 camera. </span>
<span class="sd">    </span>
<span class="sd">    CATEGORY:</span>
<span class="sd">           ???</span>
<span class="sd">    </span>
<span class="sd">    CALLING SEQUENCE:</span>
<span class="sd">           RESULT = T_PERFECT_KECK(NU, D, [PUPIL=PUPIL])</span>
<span class="sd">    </span>
<span class="sd">    INPUTS:</span>
<span class="sd">           NU:  Normalized spatial frequency in the image plane, in</span>
<span class="sd">                units of D/lambda.</span>
<span class="sd">    </span>
<span class="sd">           D:   The diameter of the Keck pupil, in meters, to which the</span>
<span class="sd">                spatial frequencies are normalized, i.e. not necessarily</span>
<span class="sd">                the oft-quoted effective diameter of 10 meters.  </span>
<span class="sd">                If D is a scalar or a 1-element array, this value is</span>
<span class="sd">                used.  Otherwise D must be a structure with the tag &quot;D&quot;</span>
<span class="sd">                defined, as per the definition of PARAMS in</span>
<span class="sd">                MTFFUNC_KECK. </span>
<span class="sd">    </span>
<span class="sd">    KEYWORD PARAMETERS:</span>
<span class="sd">           PUPIL:      Set this keyword to a string to select the</span>
<span class="sd">                       NIRC2 pupil-stop.  Available choices are</span>
<span class="sd">                          &#39;OPEN&#39;</span>
<span class="sd">                          &#39;LARGEHEX&#39;</span>
<span class="sd">                          &#39;MEDIUMHEX&#39;</span>
<span class="sd">                          &#39;SMALLHEX&#39;</span>
<span class="sd">                          &#39;INCIRCLE&#39;</span>
<span class="sd">                       If this keyword is not set, the default pupil is</span>
<span class="sd">                       &#39;LARGEHEX&#39;. (See documentation for NIRC2PUPIL.)</span>
<span class="sd">    </span>
<span class="sd">    OUTPUTS:</span>
<span class="sd">           RESULT:  The diffraction limited MTF (N.B. not the square of</span>
<span class="sd">           the MTF).</span>
<span class="sd">    </span>
<span class="sd">    PROCEDURE:</span>
<span class="sd">           1) Retrieves a pupil image from NIRC2PUPIL</span>
<span class="sd">           2) Computes the 2-D autocorrelation function of the pupil</span>
<span class="sd">           3) Radially bins and averages the 2-D autocorrelation</span>
<span class="sd">              function into a 1-D MTF.</span>
<span class="sd">           4) Interpoates the 1-D MTF onto the grid of normalized</span>
<span class="sd">              spatial frequencies, NU, defined by the user.</span>
<span class="sd">    </span>
<span class="sd">    PROCEDURE CALLS:</span>
<span class="sd">           NIRC2PUPIL(), CONVOLVE()</span>
<span class="sd">    </span>
<span class="sd">    MODIFICATION HISTORY:</span>
<span class="sd">           Written by Christopher D. Sheehy, January 2006.</span>
<span class="sd">           Commented by Nate McCrady, January 2008.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Some image testing to catch unexpected inputs</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input NU cannot be less than zeros.&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">p</span>

    <span class="c1"># Constants</span>
    <span class="n">mperpix</span> <span class="o">=</span> <span class="mf">0.04</span>
    <span class="n">npix</span> <span class="o">=</span> <span class="mi">550</span>
    
    <span class="c1"># Get the pupil image.</span>
    <span class="n">pupim</span> <span class="o">=</span> <span class="n">nirc2pupil</span><span class="p">(</span><span class="n">npix</span><span class="o">=</span><span class="n">npix</span><span class="p">,</span> <span class="n">du</span><span class="o">=</span><span class="n">mperpix</span><span class="p">,</span> <span class="n">pmsname</span><span class="o">=</span><span class="n">pupil</span><span class="p">)</span>  

    <span class="c1"># Compute the 2D autocorr of the pupil image</span>
    <span class="n">pupcor</span> <span class="o">=</span> <span class="n">autocorr2d</span><span class="p">(</span><span class="n">pupim</span><span class="p">)</span>

    <span class="c1"># normalize to max of 1.0</span>
    <span class="n">pupcor</span> <span class="o">/=</span> <span class="n">pupcor</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># identify the center of the autocorrelated pupil</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">pupcor</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
    <span class="n">xcen</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">%</span> <span class="n">npix</span>
    <span class="n">ycen</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">/</span> <span class="n">npix</span>

    <span class="c1"># Radially bin/average to produce a 1-D MTF</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">radialProfile</span><span class="o">.</span><span class="n">azimuthalAverage</span><span class="p">(</span><span class="n">pupcor</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="n">xcen</span><span class="p">,</span><span class="n">ycen</span><span class="p">],</span> 
                                         <span class="n">ignoreNAN</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pix</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">rms</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Define cutoff frequency in pixel units</span>
    <span class="n">maxpix</span> <span class="o">=</span> <span class="n">D</span> <span class="o">/</span> <span class="n">mperpix</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">/</span> <span class="n">maxpix</span>
    <span class="c1"># Radially binning doesn&#39;t give a value for r=0, which must be 1</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

    <span class="c1"># The interpolation might return very small negative values that</span>
    <span class="c1"># by definition should be zero, so make them such</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">val</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">newval</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">interp</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newval</span></div>

<div class="viewcode-block" id="autocorr2d"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.autocorr2d">[docs]</a><span class="k">def</span> <span class="nf">autocorr2d</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2D auto correlation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">npix</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">d_fft</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">d_fft</span> <span class="o">*</span> <span class="n">d_fft</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
    <span class="n">tmp2</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span>
    <span class="n">tmp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span>
    <span class="n">tmp4</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">tmp3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tmp4</span></div>
    


<div class="viewcode-block" id="nirc2pupil"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.nirc2pupil">[docs]</a><span class="k">def</span> <span class="nf">nirc2pupil</span><span class="p">(</span><span class="n">npix</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">du</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pmsname</span><span class="o">=</span><span class="s1">&#39;largehex&#39;</span><span class="p">,</span> <span class="n">pmrangl</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NAME:</span>
<span class="sd">    	NIRC2PUPIL</span>
<span class="sd">    </span>
<span class="sd">    PURPOSE:</span>
<span class="sd">    	Calculate NIRC2 pupil image</span>
<span class="sd">    </span>
<span class="sd">    EXPLANATION:</span>
<span class="sd">    	Calculate pupil image for any pupil stop, pupil angle, and image</span>
<span class="sd">    	scale, for use by NIRC2PSF in determining theoretical PSF.</span>
<span class="sd">    </span>
<span class="sd">    CALLING SEQUENCE:</span>
<span class="sd">    	result = NIRC2PUPIL( [NPIX=, DU=, PMSNAME=, PMRANGL= ])</span>
<span class="sd">    </span>
<span class="sd">    INPUTS:</span>
<span class="sd">    	none.</span>
<span class="sd">    </span>
<span class="sd">    OUTPITS:</span>
<span class="sd">    	result = binary image of pupil</span>
<span class="sd">    </span>
<span class="sd">    OPTIONAL INPUT KEYWORDS:</span>
<span class="sd">    	NPIX = size of pupil image, in pixels</span>
<span class="sd">    </span>
<span class="sd">    	DU = platescale of pupil image, in m/pixel at the telescope primary</span>
<span class="sd">    </span>
<span class="sd">    	PMSNAME = pupil stop name, eg. &#39;largehex&#39; (the default).</span>
<span class="sd">    </span>
<span class="sd">    	PMRANGL = pupil drive&#39;s angular position (for rotated pupil images).</span>
<span class="sd">    	  NOT TESTED.  There could be an offset and/or a sign flip needed!</span>
<span class="sd">    </span>
<span class="sd">    EXAMPLE:</span>
<span class="sd">    	pupil = NIRC2PUPIL(npix=512, du=0.05, PMSNAME=&#39;open&#39;)</span>
<span class="sd">    </span>
<span class="sd">    ERROR HANDLING:</span>
<span class="sd">    	none</span>
<span class="sd">    </span>
<span class="sd">    RESTRICTIONS:</span>
<span class="sd">    	none</span>
<span class="sd">    </span>
<span class="sd">    NOTES:</span>
<span class="sd">    	The dimentions are based on Keck KAON 253 and the NIRC2 pupil</span>
<span class="sd">    	  stop drawings.</span>
<span class="sd">    </span>
<span class="sd">    PROCEDURES USED:</span>
<span class="sd">    	none</span>
<span class="sd">    </span>
<span class="sd">    MODIFICATION HISTORY:</span>
<span class="sd">    	Original writen May 2004, A. Bouchez, W.M. Keck Observatory</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">du</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">du</span> <span class="o">=</span> <span class="mf">2.124e-6</span> <span class="o">/</span> <span class="p">(</span><span class="n">npix</span> <span class="o">*</span> <span class="mf">0.00995</span> <span class="o">/</span> <span class="mf">206265.0</span><span class="p">)</span>

    <span class="c1"># 1. Define dimensions of pupil in inches based on engineering drawings.</span>
    <span class="n">pmsstr</span> <span class="o">=</span> <span class="n">pmsname</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="n">pmsInfo</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pmsInfo</span><span class="p">[</span><span class="s1">&#39;OPEN&#39;</span><span class="p">]</span> <span class="o">=</span>      <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4900</span><span class="p">,</span> <span class="mf">0.4200</span><span class="p">,</span> <span class="mf">0.3500</span><span class="p">,</span> <span class="mf">0.2800</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">,</span> <span class="mf">0.0000</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">pmsInfo</span><span class="p">[</span><span class="s1">&#39;LARGEHEX&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4790</span><span class="p">,</span> <span class="mf">0.4090</span><span class="p">,</span> <span class="mf">0.3390</span><span class="p">,</span> <span class="mf">0.2690</span><span class="p">,</span> <span class="mf">0.1170</span><span class="p">,</span> <span class="mf">0.0020</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">pmsInfo</span><span class="p">[</span><span class="s1">&#39;MEDIUMHEX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4710</span><span class="p">,</span> <span class="mf">0.4010</span><span class="p">,</span> <span class="mf">0.3310</span><span class="p">,</span> <span class="mf">0.2610</span><span class="p">,</span> <span class="mf">0.1250</span><span class="p">,</span> <span class="mf">0.0030</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">pmsInfo</span><span class="p">[</span><span class="s1">&#39;SMALLHEX&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4510</span><span class="p">,</span> <span class="mf">0.3810</span><span class="p">,</span> <span class="mf">0.3110</span><span class="p">,</span> <span class="mf">0.2410</span><span class="p">,</span> <span class="mf">0.1450</span><span class="p">,</span> <span class="mf">0.0030</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">pmsInfo</span><span class="p">[</span><span class="s1">&#39;INCIRCLE&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3920</span><span class="p">,</span> <span class="mf">0.1325</span><span class="p">,</span> <span class="mf">0.0030</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
               
    <span class="n">d</span> <span class="o">=</span> <span class="n">pmsInfo</span><span class="p">[</span><span class="n">pmsstr</span><span class="p">]</span>

    <span class="c1"># m/inch derived in KAON 253</span>
    <span class="n">pms_pscl</span> <span class="o">=</span> <span class="mf">0.0899</span>

    <span class="n">pupil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npix</span><span class="p">,</span> <span class="n">npix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npix</span><span class="p">)</span>
    <span class="n">tmpy</span><span class="p">,</span> <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
    <span class="n">xypupil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tmpx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">tmpy</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">dist_circle</span><span class="p">(</span><span class="n">npix</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="n">npix</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">npix</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>

    <span class="c1"># 1. Create INCIRCLE pupil</span>
    <span class="k">if</span> <span class="n">pmsstr</span> <span class="o">==</span> <span class="s1">&#39;INCIRCLE&#39;</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">r</span> <span class="o">*</span> <span class="n">du</span> <span class="o">*</span> <span class="n">pms_pscl</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> 
                     <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">du</span> <span class="o">*</span> <span class="n">pms_pscl</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">pupil</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> 
                      <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span> 
                      <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">1.1</span><span class="p">],</span>
                      <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">1.1</span><span class="p">],</span> 
                      <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="n">pmrangl</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ang</span><span class="p">)):</span>
            <span class="n">rmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="n">ii</span><span class="p">])],</span>
                             <span class="p">[</span>   <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="n">ii</span><span class="p">])]])</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">npix</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">rmat</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">du</span> <span class="o">*</span> <span class="n">pms_pscl</span><span class="p">))</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">nxutils</span><span class="o">.</span><span class="n">points_inside_poly</span><span class="p">(</span><span class="n">xypupil</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pupil</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="n">pupil</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 2. For others, compute vertices for one sextant (in mm)</span>
        <span class="n">cosa</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">30.0</span><span class="p">))</span>
        <span class="n">sina</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">30.0</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">cosa</span>   <span class="c1"># length of segment edge</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="n">cosa</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">sina</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cosa</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">sina</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">s</span><span class="o">*</span><span class="n">cosa</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cosa</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">sina</span><span class="p">],</span>
                       <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">cosa</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cosa</span><span class="p">],</span>
                       <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">cosa</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cosa</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">sina</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sina</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">cosa</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">sina</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">cosa</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">/</span><span class="n">cosa</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">sina</span><span class="p">]])</span>
        <span class="c1"># mirror image across Y axis</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">v0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)])</span>
    
        <span class="c1"># Fill in pupil image (dimensions in pixels)</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">((</span><span class="mi">60</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="n">pmrangl</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
            <span class="n">rmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span>
                             <span class="p">[</span>   <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">[</span><span class="n">i</span><span class="p">])]])</span>
            <span class="n">rv0</span> <span class="o">=</span> <span class="n">npix</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">rmat</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">du</span> <span class="o">*</span> <span class="n">pms_pscl</span><span class="p">))</span>
            <span class="n">rv1</span> <span class="o">=</span> <span class="n">npix</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">rmat</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">du</span> <span class="o">*</span> <span class="n">pms_pscl</span><span class="p">))</span>

            <span class="n">rv0tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">rv0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">rv0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rv0</span><span class="p">))])</span>
            <span class="n">inpupil</span> <span class="o">=</span> <span class="n">nxutils</span><span class="o">.</span><span class="n">points_inside_poly</span><span class="p">(</span><span class="n">xypupil</span><span class="p">,</span> <span class="n">rv0</span><span class="p">)</span>
            <span class="n">inpupil2</span> <span class="o">=</span> <span class="n">nxutils</span><span class="o">.</span><span class="n">points_inside_poly</span><span class="p">(</span><span class="n">xypupil</span><span class="p">,</span> <span class="n">rv0tmp</span><span class="p">)</span>
            <span class="n">inpupil</span> <span class="o">=</span> <span class="n">inpupil</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pupil</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">pupil</span><span class="p">[</span><span class="n">inpupil</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">inpupil</span> <span class="o">=</span> <span class="n">nxutils</span><span class="o">.</span><span class="n">points_inside_poly</span><span class="p">(</span><span class="n">xypupil</span><span class="p">,</span> <span class="n">rv1</span><span class="p">)</span>
            <span class="n">inpupil</span> <span class="o">=</span> <span class="n">inpupil</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pupil</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">pupil</span><span class="p">[</span><span class="n">inpupil</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1"># Cut out circular secondary</span>
        <span class="k">if</span> <span class="n">pmsstr</span> <span class="o">==</span> <span class="s1">&#39;OPEN&#39;</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">du</span> <span class="o">&lt;</span> <span class="mf">1.30</span><span class="p">)</span>
            <span class="n">pupil</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">pupil</span></div>

    
<div class="viewcode-block" id="dist_circle"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.dist_circle">[docs]</a><span class="k">def</span> <span class="nf">dist_circle</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">    NAME: </span>
<span class="sd">         DIST_CIRCLE</span>
<span class="sd">    PURPOSE:      </span>
<span class="sd">         Form a square array where each value is its distance to a given center.</span>
<span class="sd">    EXPLANATION:</span>
<span class="sd">         Returns a square array in which the value of each element is its </span>
<span class="sd">         distance to a specified center. Useful for circular aperture photometry.</span>
<span class="sd">    </span>
<span class="sd">    CALLING SEQUENCE:</span>
<span class="sd">         DIST_CIRCLE, IM, N, [ XCEN, YCEN,  /DOUBLE ]</span>
<span class="sd">    </span>
<span class="sd">    INPUTS:</span>
<span class="sd">         N = either  a scalar specifying the size of the N x N square output</span>
<span class="sd">                  array, or a 2 element vector specifying the size of the</span>
<span class="sd">                  N x M rectangular output array.</span>
<span class="sd">    </span>
<span class="sd">    OPTIONAL INPUTS:</span>
<span class="sd">         XCEN,YCEN = Scalars designating the X,Y pixel center.  These need</span>
<span class="sd">                  not be integers, and need not be located within the</span>
<span class="sd">                  output image.   If not supplied then the center of the output</span>
<span class="sd">                  image is used (XCEN = YCEN = (N-1)/2.).</span>
<span class="sd">    </span>
<span class="sd">    OUTPUTS:</span>
<span class="sd">          IM  - N by N (or M x N) floating array in which the value of each </span>
<span class="sd">                  pixel is equal to its distance to XCEN,YCEN</span>
<span class="sd">    </span>
<span class="sd">    OPTIONAL INPUT KEYWORD:</span>
<span class="sd">          /DOUBLE - If this keyword is set and nonzero, the output array will</span>
<span class="sd">                  be of type DOUBLE rather than floating point.</span>
<span class="sd">    </span>
<span class="sd">    EXAMPLE:</span>
<span class="sd">          Total the flux in a circular aperture within 3&#39; of a specified RA</span>
<span class="sd">          and DEC on an 512 x 512 image IM, with a header H.</span>
<span class="sd">    </span>
<span class="sd">                  IDL&gt; adxy, H, RA, DEC, x, y       Convert RA and DEC to X,Y</span>
<span class="sd">          IDL&gt; getrot, H, rot, cdelt        CDELT gives plate scale deg/pixel</span>
<span class="sd">          IDL&gt; cdelt = cdelt*3600.          Convert to arc sec/pixel</span>
<span class="sd">          IDL&gt; dist_circle, circle, 512, x, y  ;Create a distance circle image</span>
<span class="sd">          IDL&gt; circle = circle*abs(cdelt[0])   ;Distances now given in arcseconds</span>
<span class="sd">          IDL&gt; good = where(circle LT 180)  ;Within 3 arc minutes</span>
<span class="sd">          IDL&gt; print,total( IM[good] )      Total pixel values within 3&#39;</span>
<span class="sd">    </span>
<span class="sd">    RESTRICTIONS:</span>
<span class="sd">          The speed of DIST_CIRCLE decreases and the the demands on virtual</span>
<span class="sd">          increase as the square of the output dimensions.   Users should</span>
<span class="sd">          dimension the output array as small as possible, and re-use the</span>
<span class="sd">          array rather than re-calling DIST_CIRCLE</span>
<span class="sd">    </span>
<span class="sd">    MODIFICATION HISTORY:</span>
<span class="sd">          Adapted from DIST    W. Landsman            March 1991</span>
<span class="sd">          Allow a rectangular output array   W. Landsman     June 1994</span>
<span class="sd">          Converted to IDL V5.0   W. Landsman   September 1997</span>
<span class="sd">          Add /DOUBLE keyword, make XCEN,YCEN optional  W. Landsman Jun 1998</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">size</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xcen</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">ycen</span> <span class="o">=</span> <span class="p">(</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xcen</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ycen</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
    
    <span class="n">yy</span><span class="p">,</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">xx</span> <span class="o">-=</span> <span class="n">xcen</span>
    <span class="n">yy</span> <span class="o">-=</span> <span class="n">ycen</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">r</span></div>
    

             
<div class="viewcode-block" id="t_perfect"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.t_perfect">[docs]</a><span class="k">def</span> <span class="nf">t_perfect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ee</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            T_PERFECT</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Computes the analytic diffraction limited MTF of a</span>
<span class="sd">            circular pupil with a circular central obscuration.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            What goes here?</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            RESULT = T_PERFECT(NU, PUPIL)</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            NU:  Normalized spatial frequency in the image plane, in</span>
<span class="sd">                 units of D/lambda where D is the pupil diameter and</span>
<span class="sd">                 lambda is the observing wavelength     need not be</span>
<span class="sd">                 regularly gridded</span>
<span class="sd">    </span>
<span class="sd">            PUPIL:  The pupil&#39;s central obscuration, defined as the</span>
<span class="sd">                 ratio of the obscuration&#39;s diameter to the pupil&#39;s</span>
<span class="sd">                 diameter.  If PUPIL is a scalar or a 1-element array,</span>
<span class="sd">                 this value is used.  Otherwise PUPIL must be a structure</span>
<span class="sd">                 with the tag &quot;PUPIL&quot; defined, as per the definition of</span>
<span class="sd">                 PARAMS in MTFFUNC_KECK. </span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL INPUTS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            RESULT:  The diffraction limited pupil MTF (N.B. not the</span>
<span class="sd">            square of the MTF)</span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL OUTPUTS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher D. Sheehy, January 2006.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input NU cannot be less than zero.&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ee</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">ee</span><span class="p">[</span><span class="s1">&#39;pupil&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ee</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Assume size = 1</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">ee</span>

    <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">e</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Central obscuration cannot be &lt; 0 or &gt;= 1&#39;</span><span class="p">)</span>
        
    <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ind0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">A</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">])</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">ind0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span><span class="o">/</span><span class="n">e</span>
        <span class="n">B</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">-</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">e</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">B</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">B</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">ind0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">e</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">e</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">e</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">e</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">chi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">e</span><span class="p">))</span>
    <span class="n">chi</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="n">C</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">e</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">C</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmp</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">C</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(((</span><span class="mi">1</span><span class="o">+</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">e</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">tmp</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>

    <span class="n">C</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">e</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">C</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">Tp</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Tp</span></div>
    
<div class="viewcode-block" id="t_pix"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.t_pix">[docs]</a><span class="k">def</span> <span class="nf">t_pix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            T_PIX</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Analytically computes the MTF of an ideal square pixel,</span>
<span class="sd">            i.e. the detector MTF.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ???</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            RESULT = T_PIX(NU, PARAMS)</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            NU:  Normalized spatial frequency in the image plane, in</span>
<span class="sd">                 units of D/lambda.</span>
<span class="sd">    </span>
<span class="sd">            PARAMS:  Must be a structure containing the tags &quot;lambda&quot;,</span>
<span class="sd">                 &quot;D&quot;, &quot;F&quot;, and &quot;A&quot; as defined in the documentation for</span>
<span class="sd">                 MTFFUNC_KECK.</span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL INPUTS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            The detector MTF (N.B. not the square of the MTF)</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE CALLS:</span>
<span class="sd">            SINC()</span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher Sheehy, January 2006.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input NU cannot be less than zero.&#39;</span><span class="p">)</span>
    
    <span class="n">d</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
    <span class="n">wave</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;Apix&#39;</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span>

    <span class="c1"># Effective focal ratio</span>
    <span class="n">fratio</span> <span class="o">=</span> <span class="n">f</span> <span class="o">/</span> <span class="n">d</span>
    
    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">wave</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">f</span> <span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input D, wave, Apix, and F must all be &gt; 0.&#39;</span><span class="p">)</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">wave</span> <span class="o">*</span> <span class="n">fratio</span> <span class="o">/</span> <span class="n">a</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">delta</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="t_atmos_ao"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.t_atmos_ao">[docs]</a><span class="k">def</span> <span class="nf">t_atmos_ao</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            T_ATMOS_AO</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Computes the AO filtered atmospheric MTF assuming a modified</span>
<span class="sd">            Kolmogorov atmospheric phase error power spectrum with a</span>
<span class="sd">            finite outer scale of turbulence.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ????</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            RESULT = T_ATMOS_AO(NU, PARAMS)</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            NU:  Normalized spatial frequency in the image plane, in</span>
<span class="sd">                 units of D/lambda.</span>
<span class="sd">            PARAMS:  A structure of parameters, defined in the</span>
<span class="sd">                 documentation for MTFFUNC_KECK</span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL INPUTS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            RESULT:  The AO+atmosphere MTF     the same size as NU.</span>
<span class="sd">    </span>
<span class="sd">     RESTRICTIONS:</span>
<span class="sd">            NU must be greater than zero.</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE CALLS:</span>
<span class="sd">            STRUC_FUNC()</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE:</span>
<span class="sd">            Computes the structure function for the AO filtered</span>
<span class="sd">            Kolmogorov power spectrum using STRUC_FUNC and exponentiates</span>
<span class="sd">            to yield the atmosphere + AO MTF.</span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher D. Sheehy, January 2006.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input NU cannot be less than zero.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input PARAMS must be a dictionary.&#39;</span><span class="p">)</span>

    <span class="n">wave</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span>
    <span class="n">flength</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span>
    <span class="n">diam</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">diam</span> <span class="o">*</span> <span class="n">x</span>

    <span class="c1"># Comput the structure function. Can be time consuming.</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">structure_function</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">mtf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span>

    <span class="n">t_at_ao</span> <span class="o">=</span> <span class="n">mtf</span>

    <span class="k">return</span> <span class="n">t_at_ao</span></div>

<div class="viewcode-block" id="phi_atmos_ao"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.phi_atmos_ao">[docs]</a><span class="k">def</span> <span class="nf">phi_atmos_ao</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">unmod</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            PHI_ATMOS_AO</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Calculates the AO filtered atmospheric power spectrum for</span>
<span class="sd">            spatial frequencies in the pupil plane, Phi_AO = Phi*(1-H)^2</span>
<span class="sd">            where Phi is the unfiltered atmospheric power spectrum and H</span>
<span class="sd">            is the Fourier transform of the deformable mirror&#39;s (DM&#39;s)</span>
<span class="sd">            influence function.  The default behavior is to use modified</span>
<span class="sd">            Kolmogorov power spectrum with finite outer scale and the</span>
<span class="sd">            influence function for the Keck AO system&#39;s DM.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ???</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            Result = PHI_ATMOS_AO(KAPPA, PARAMS, [unmod=unmod, tat=tat])</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            KAPPA:  A vector of spatial frequencies in the pupil plane,</span>
<span class="sd">                    in m^-1</span>
<span class="sd">            PARAMS: A structure of parameters as defined in the</span>
<span class="sd">                    documentation for MTFFUNC_KECK </span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            /UNMOD: Set this keyword to use an unmodified Kolmogorov</span>
<span class="sd">                    atmospheric power spectrum, i.e. with an infinite</span>
<span class="sd">                    outer scale.</span>
<span class="sd">            /TAT:   Set this keyword to use a modified Tatarski power</span>
<span class="sd">                    spectrum, i.e. one with both a finite outer scale</span>
<span class="sd">                    and finite inner scale (WARNING: UNTESTED).  If this</span>
<span class="sd">                    keyword is invoked, the PARAMS structure must contain</span>
<span class="sd">                    an extra tag, &quot;Inner:&quot;, that is the inner scale of</span>
<span class="sd">                    turbulence in meters.</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            Result: The AO filtered atmospheric power spectrum, of</span>
<span class="sd">                    evaluated at and the same size as KAPPA.</span>
<span class="sd">    </span>
<span class="sd">     RESTRICTIONS:</span>
<span class="sd">            If the /UNMOD keyword is set, an input KAPPA of zero will</span>
<span class="sd">            cause a divide by 0 error, and RESULT will be Infinity,</span>
<span class="sd">            because the power at zero spatial frequency for an infinite</span>
<span class="sd">            outer scale is infinity.</span>
<span class="sd">    </span>
<span class="sd">            Works for the Keck DM&#39;s influence function.  If the user</span>
<span class="sd">            wishes to use a different influence function, replace the</span>
<span class="sd">            call to FT_INFL_FUNC within the routine with another</span>
<span class="sd">            function that returns the Fourier transform of the</span>
<span class="sd">            appropriate influence function.  This function should take as</span>
<span class="sd">            inputs KAPPA and PARAMS (the user may add other tags to the</span>
<span class="sd">            PARAMS structure as necessary) and return the FT of the</span>
<span class="sd">            influence function as projected onto the pupil plane,</span>
<span class="sd">            evaluated at the inpute KAPPA.</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE CALLS:</span>
<span class="sd">            PHI__ATMOS(), FT_INFL_FUNC()</span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher Sheehy, January 2006.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">delta</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
    
    <span class="n">H</span> <span class="o">=</span> <span class="n">ft_infl_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    
    <span class="c1"># Unmodified Kolmogorov power spectrum</span>
    <span class="n">phi_at</span> <span class="o">=</span> <span class="n">phi_atmos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">unmod</span><span class="o">=</span><span class="n">unmod</span><span class="p">,</span> <span class="n">tat</span><span class="o">=</span><span class="n">tat</span><span class="p">)</span>

    <span class="c1"># AO filter power spectrum, H is already multiplied by p[&#39;w&#39;]</span>
    <span class="n">phi_at_ao</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">H</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi_at</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">H</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">return</span> <span class="n">phi_at_ao</span></div>


<div class="viewcode-block" id="phi_atmos"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.phi_atmos">[docs]</a><span class="k">def</span> <span class="nf">phi_atmos</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">tat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unmod</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            PHI_ATMOS</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Calculates a modified Kolmogorov atmospheric phase error</span>
<span class="sd">            power spectrum with finite outer scale of turbulence.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ???</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            RESULT = PHI_ATMOS(KAPPA, PARAMS, [unmod=unmod, tat=tat])</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            KAPPA:  A vector of spatial frequencies in the pupil plane,</span>
<span class="sd">                    in m^-1, at which the power spectrum is evaluated</span>
<span class="sd">                    (need not be regularly gridded).</span>
<span class="sd">            PARAMS:  A structure of parameters as definted in the</span>
<span class="sd">                    documentation for MTFFUNC_KECK</span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            /UNMOD:  Set this keyword to return an unmodified Kolmogorov</span>
<span class="sd">                     power spectrum, i.e. one with an infinite outer</span>
<span class="sd">                     scale. </span>
<span class="sd">            /TAT:    Set this keyword to return a modified Tatarski power</span>
<span class="sd">                     spectrum, i.e. one with both a finite outer scale</span>
<span class="sd">                     and finite inner scale (WARNING: UNTESTED).  If this</span>
<span class="sd">                     keyword is invoked, the PARAMS structure must contain</span>
<span class="sd">                     an extra tag, &quot;Inner:&quot;, that is the inner scale of</span>
<span class="sd">                     turbulence in meters.</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            RESULT:  The Kolmogorov atmospheric power spectrum, of same</span>
<span class="sd">                     size as input KAPPA.</span>
<span class="sd">    </span>
<span class="sd">     RESTRICTIONS:</span>
<span class="sd">            If the /UNMOD keyword is set, an input KAPPA of zero will</span>
<span class="sd">            cause a divide by 0 error, and RESULT will be Infinity,</span>
<span class="sd">            because the power at zero spatial frequency for an infinite</span>
<span class="sd">            outer scale is infinity.</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE:</span>
<span class="sd">            1) The Kolmogorov spectrum with inifinte outer scale is</span>
<span class="sd">               calculated.  If the /UNMOD keyword is set, this is</span>
<span class="sd">               immediately returned.</span>
<span class="sd">            2) The Kolmogorov spectrum with finite outer scale is</span>
<span class="sd">               calculated.  Since the power at spatial scales much less</span>
<span class="sd">               than the outer scale should be left unaffected, the</span>
<span class="sd">               spectrum is normalized to have the same power at a very</span>
<span class="sd">               high spatial frequency, 100 m^-1.</span>
<span class="sd">               </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher Sheehy, January 2006</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;L0&#39;</span><span class="p">]</span>
    <span class="n">r0</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;r0&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">unmod</span><span class="p">:</span>
        <span class="n">phi_unmod</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0229</span> <span class="o">/</span> <span class="p">(</span><span class="n">r0</span><span class="o">**</span><span class="p">(</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)))</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">11.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">phi_unmod</span>

    <span class="k">if</span> <span class="n">tat</span><span class="p">:</span>
        <span class="n">l0</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;inner&#39;</span><span class="p">]</span>
        <span class="c1"># UNTESTED! pretty sure this should be normalized in the </span>
        <span class="c1"># same way as below</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">l0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">11.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">phi</span>
    
    <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0229</span> <span class="o">/</span> <span class="p">(</span><span class="n">r0</span><span class="o">**</span><span class="p">(</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">11.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.0229</span> <span class="o">/</span> <span class="p">(</span><span class="n">r0</span><span class="o">**</span><span class="p">(</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">100.0</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">11.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">))</span> 
    <span class="n">a</span> <span class="o">/=</span> <span class="p">((</span><span class="mf">0.0229</span> <span class="o">/</span> <span class="p">(</span><span class="n">r0</span><span class="o">**</span><span class="p">(</span><span class="mf">5.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">100.0</span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">11.0</span><span class="o">/</span><span class="mf">6.0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">phi</span></div>

    
<div class="viewcode-block" id="ft_infl_func"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.ft_infl_func">[docs]</a><span class="k">def</span> <span class="nf">ft_infl_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    +</span>
<span class="sd">     NAME:</span>
<span class="sd">            FT_INFL_FUNC</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Evaltuates the Fourier transform of the Keck AO system&#39;s</span>
<span class="sd">            deformable mirror at given input spatial frequency in the</span>
<span class="sd">            pupil plane.  Uses the functional form for the influence</span>
<span class="sd">            function given by van Dam, et al., 2004, Applied Optics, 43,</span>
<span class="sd">            5452.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ???</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            Result = FT_INFL_FUNC(KAPPA, PARAMS)</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            KAPPA:  Spatial frequency in the pupil plane of the telescope</span>
<span class="sd">                    in m^-1.</span>
<span class="sd">            PARAMS: A structure of parameters as defined in the</span>
<span class="sd">                    documentation for MTFFUNC_KECK.  Only SIGMA and W</span>
<span class="sd">                    need be defined. </span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            Result:  The FT of the influence function, evaluated at and</span>
<span class="sd">                     of the same size as KAPPA.  The output is multiplied</span>
<span class="sd">                     by W before output.  W=2 gives perfect AO correction</span>
<span class="sd">                     at zero spatial frequency.</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE:</span>
<span class="sd">            The FT of the influence function has a set functional form,</span>
<span class="sd">            the difference of two Gaussians, and depends only on the</span>
<span class="sd">            parameter SIGMA (as defined in PARAMS) that is on the order</span>
<span class="sd">            of the separation between DM actuators.</span>
<span class="sd">    </span>
<span class="sd">            The result is multiplied by a constant scaling factor w, defined in</span>
<span class="sd">            PARAMS, before being output.</span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher Sheehy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inputIterable</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inputIterable</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">sig1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">sig1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">sig1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>   <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="n">f1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">40.</span><span class="p">)</span>
    <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">40.</span><span class="p">)</span>

    <span class="n">f1</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="n">a</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="n">f2</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="n">b</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">w1</span> <span class="o">*</span> <span class="p">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inputIterable</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">H</span></div>
                 

<div class="viewcode-block" id="structure_function"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.structure_function">[docs]</a><span class="k">def</span> <span class="nf">structure_function</span><span class="p">(</span><span class="n">rr</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">phi_call</span><span class="o">=</span><span class="n">phi_atmos_ao</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            STRUC_FUNC</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Calculates the structure function, D(r), where r is the</span>
<span class="sd">            distance between two points in the pupil plane of the</span>
<span class="sd">            telescope in meter.  Default behavior is to calculate D(r)</span>
<span class="sd">            for an AO corrected Kolmogorov atmospheric power spectrum</span>
<span class="sd">            with finite outer scale.  However, the user can define any</span>
<span class="sd">            arbitrary atmospheric power spectra for which to calculate</span>
<span class="sd">            D(r).</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ???</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            RESULT = STRUC_FUNC(R, PARAMS, [phi_call=phi_call])</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            R:  A vector of radii in the pupil plane, in meters</span>
<span class="sd">    </span>
<span class="sd">            PARAMS:  A structure of parameters as defined in the</span>
<span class="sd">            documentation for MTFFUNC_KECK</span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL INPUTS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            PHI_CALL:  The default behavior of STRUC_FUNC, i.e. not</span>
<span class="sd">                       defning PHI_CALL, is to calculate the structure </span>
<span class="sd">                       function assuming a modified Kolmogorov power</span>
<span class="sd">                       spectrum with a finite outer scale and corrected</span>
<span class="sd">                       by adaptive optics.  If the user wishes to find</span>
<span class="sd">                       D(r) for a different power spectrum, PHI_CALL</span>
<span class="sd">                       should be a string that, as executed, calls an IDL</span>
<span class="sd">                       function that returns the power spectrum for </span>
<span class="sd">                       input spatial frequencies KAPPA (as defined in the</span>
<span class="sd">                       documentation for PHI_ATMOS/PHI_ATMOS_AO).</span>
<span class="sd">                       This function must be structured as follows:</span>
<span class="sd">    </span>
<span class="sd">                           FUNCTION MYFUNCT, KAPPA, PARAMS, KEYWORDS=...</span>
<span class="sd">                             (compute the atmospheric power spectrum PHI</span>
<span class="sd">                              at given X for input parameters PARAMS)</span>
<span class="sd">                              RETURN, PHI</span>
<span class="sd">                           END</span>
<span class="sd">    </span>
<span class="sd">                       The PARAMS input to the function is the same</span>
<span class="sd">                       structure as the PARAMS input into STRUC_FUNC.</span>
<span class="sd">    </span>
<span class="sd">                       PHI_CALL MUST HAVE &#39;k&#39; AS THE SPATIAL FREQUENCY</span>
<span class="sd">                       VARIABLE NAME &#39;k&#39; AND &#39;p&#39; AS THE PARAMETER</span>
<span class="sd">                       STRUCTURE VARAIBLE NAME!</span>
<span class="sd">                       </span>
<span class="sd">                       Example: The function PHI_ATMOS returns the</span>
<span class="sd">                       uncorrected atmospheric power spectrum, and would</span>
<span class="sd">                       be called as such:</span>
<span class="sd">    </span>
<span class="sd">                           IDL&gt; x=findgen(10)</span>
<span class="sd">                           IDL&gt; phi=PHI_ATMOS(x,params)</span>
<span class="sd">    </span>
<span class="sd">                       where params has already been defined and is a</span>
<span class="sd">                       structure containing information for PHI_ATMOS to</span>
<span class="sd">                       be able to calculate the power spectrum.  In the</span>
<span class="sd">                       call to STRUC_FUNC, setting the keyword</span>
<span class="sd">    </span>
<span class="sd">                           PHI_CALL = &#39;PHI_ATMOS(k,p)&#39;</span>
<span class="sd">    </span>
<span class="sd">                       forces STRUC_FUNC to use this power spectrum in</span>
<span class="sd">                       calculating D(r).  </span>
<span class="sd">    </span>
<span class="sd">                       PHI_ATMOS also accepts keywords     for instance</span>
<span class="sd">    </span>
<span class="sd">                           IDL&gt; phi=PHI_ATMOS(x,params,/unmod)</span>
<span class="sd">    </span>
<span class="sd">                       returns an uncorrected power spectrum with an</span>
<span class="sd">                       infinite outer scale.  In this case, one would set</span>
<span class="sd">                       the keyword</span>
<span class="sd">    </span>
<span class="sd">                           PHI_CALL = &#39;PHI_ATMOS(k,p,/unmod)&#39;</span>
<span class="sd">    </span>
<span class="sd">                       Leaving the keyword PHI_CALL undefined is</span>
<span class="sd">                       equivalent to setting</span>
<span class="sd">    </span>
<span class="sd">                           PHI_CALL = &#39;PHI_ATMOS_AO(k,p)</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            RESULT:  A vector of same size as R, the structure function</span>
<span class="sd">            evaluated at R</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE CALLS:</span>
<span class="sd">            PHI_ATMOS_AO(), D_R(), QPINT1D()</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE:</span>
<span class="sd">            Utilizes the adaptive 1-d integration routine QPINT1D,</span>
<span class="sd">            written by Craig Markwardt and available from</span>
<span class="sd">            http://cow.physics.wisc.edu/~craigm/idl/idl.html</span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher Sheehy, January 2006.</span>
<span class="sd">    -</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span>
    <span class="n">d_of_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Make function is valid</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">phi_call</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Invalid phi_call in structure_function()&#39;</span><span class="p">)</span>

    <span class="c1"># Numerically compute the integral at each r necessary to construct</span>
    <span class="c1"># D(r). The integral&#39;s limits are actually 0 to infinity, but</span>
    <span class="c1"># integration 0 to 10 makes virtually no difference and is much faster.</span>
    <span class="k">def</span> <span class="nf">d_r</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">command</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># R must be a scalar, use the J bessel function of zeroth order</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">special</span><span class="o">.</span><span class="n">jn</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span> <span class="o">*</span> <span class="n">x</span>
        
        <span class="k">return</span> <span class="n">integrand</span>
        
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">rr</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pp</span><span class="p">,</span> <span class="n">phi_call</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">romberg</span><span class="p">(</span><span class="n">d_r</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">vec_func</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">d_of_r</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">return</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d_of_r</span></div>


<div class="viewcode-block" id="mtf2psf"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.mtf2psf">[docs]</a><span class="k">def</span> <span class="nf">mtf2psf</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">perfect</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            MTF2PSF</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Computes the adaptive optics PSF for the modulation</span>
<span class="sd">            transfer function (MTF) defined by a set of user supplied</span>
<span class="sd">            input parameters.  The PSF is circularly symmetric,</span>
<span class="sd">            i.e. azimuthally averaged.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ???</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            MTF2PSF, Params, Size, Psf2D, PSF1D</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            Params:   A structure of parameters defined as follows, and</span>
<span class="sd">                      which may contain more tags than listed here:</span>
<span class="sd">    </span>
<span class="sd">                      params.lambda  - observing wavelength in meters</span>
<span class="sd">                      params.f       - effective focal length at detector</span>
<span class="sd">                                       in meters</span>
<span class="sd">                      params.D -       telsscope pupil diameter in meters,</span>
<span class="sd">                                       i.e. the D/lambda at which normalized</span>
<span class="sd">                                       spatial frequency nu=1</span>
<span class="sd">                      params.Apix      - width of detector pixel in meters</span>
<span class="sd">                      params.pupil   - a string equal to the name of</span>
<span class="sd">                                       the pupil-stop of the NIRC2</span>
<span class="sd">                                       camera (see documentation for</span>
<span class="sd">                                       T_PERFECT_KECK for a list of</span>
<span class="sd">                                       available pupil-stop names) or for</span>
<span class="sd">                                       a circular pupil, the scalar</span>
<span class="sd">                                       floating point value of the</span>
<span class="sd">                                       pupil&#39;s central obscuration.</span>
<span class="sd">                      params.L0      - the outer scale of turbluence, in</span>
<span class="sd">                                       meters, for a modified Kolmogorov</span>
<span class="sd">                                       spectrum</span>
<span class="sd">                      params.sigma   - the width of the AO system</span>
<span class="sd">                                       deformable mirror&#39;s (DM&#39;s)</span>
<span class="sd">                                       influence function as projected</span>
<span class="sd">                                       onto the pupil plane, in meters.</span>
<span class="sd">                      params.w       - scaling factor for the influence</span>
<span class="sd">                                       function&#39;s Fourier transform    </span>
<span class="sd">                                       mimics variable AO correction</span>
<span class="sd">                      params.delta   - wavefront measurement error</span>
<span class="sd">                      params.cmult   - constant scaling factor of the output</span>
<span class="sd">                                       MTF</span>
<span class="sd">                      params.N       - additive constant to output MTF</span>
<span class="sd">                                       representing a noise floor</span>
<span class="sd">                      params.r0      - wavelength specific Fried</span>
<span class="sd">                                       parameter in meters</span>
<span class="sd">    </span>
<span class="sd">            Size:     A scalar, the radius of the output PSF in</span>
<span class="sd">                      arcseconds.  For instance, is Size = 1.0 and the</span>
<span class="sd">                      platescale at the detector is .01 arcsec/pixel, the</span>
<span class="sd">                      output PSF is a 200 x 200 element array.</span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL INPUTS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            /PERF:   If this keyword is set, the PSF is calculated from</span>
<span class="sd">                     the diffraction limited pupil MTF.</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            Psf2D:   A 2-dimensional array, the azimuthally averaged AO</span>
<span class="sd">                     PSF. </span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL OUTPUTS:</span>
<span class="sd">            Psf1D:   A 1-dimensional array, the 1-D PSF whose value at</span>
<span class="sd">                     each element corresponds to the value of the PSF at</span>
<span class="sd">                     the corresponding pixel.</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE CALLS:</span>
<span class="sd">            MTFFUNC_KECK(), INT_TABULATED()</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE:</span>
<span class="sd">            For the given input parameters Params, the 1-D MTF is</span>
<span class="sd">            computed via the procedure MTFFUNC_KECK.  The 1-D PSF is </span>
<span class="sd">            then given by the integral</span>
<span class="sd">                      1/</span>
<span class="sd">              PSF(w) = | MTF(nu) * nu * BesselJ_0(2*PI*w*nu)* d nu,</span>
<span class="sd">                      0/</span>
<span class="sd">            where w is dimensionless angular distance from the PSF center</span>
<span class="sd">            in units of (lambda/D), and nu is normalized spatial</span>
<span class="sd">            frequency in the image plane.  The 1-D PSF is computed,</span>
<span class="sd">            5x oversampled w.r.t. the detector platescale.  (The</span>
<span class="sd">            platescale is determined from the input parameters, </span>
<span class="sd">            Apix / f.)  From this oversampled 1-D PSF, the circularly</span>
<span class="sd">            symmetric 2-D PSF is constructed.</span>
<span class="sd">    </span>
<span class="sd">     EXAMPLE:</span>
<span class="sd">            Compute H-band NIRC2 PSF for r0 = 15 cm:</span>
<span class="sd">    </span>
<span class="sd">            r0 goes as (lambda)^(6/5), so the K-band r0 in meters is</span>
<span class="sd">            0.15 * (2.2 / 0.5)^(6./5.), since r0 = 15 cm is defined for a</span>
<span class="sd">            wavelength of 500 nm.</span>
<span class="sd">    </span>
<span class="sd">            Set up the input parameters:</span>
<span class="sd">    </span>
<span class="sd">            p    =   {wave:2.2e-6, F:557.0, D:10.99, $</span>
<span class="sd">                      Apix:27e-6, pupil:&#39;largehex&#39;, L0:30.0, $</span>
<span class="sd">                      sigma:0.56, w:1.5, delta:0.0, cmult:1.0, N:1e-5, $</span>
<span class="sd">                      r0:0.888}        </span>
<span class="sd">            sz = 1.0      return a PSF with a radius of 1 arcsecond</span>
<span class="sd">            MTF2PSF, p, sz, psf2, psf1</span>
<span class="sd">            tvscl, psf2</span>
<span class="sd">            plot, psf1</span>
<span class="sd">    </span>
<span class="sd">            nu = findgen(100)/99.</span>
<span class="sd">            T = sqrt(MTFFUNC_KECK(nu, p))     compute the PSF&#39;s corresponding MTF</span>
<span class="sd">            plot, nu, T</span>
<span class="sd">    </span>
<span class="sd">                compute the PSF for identical seeing conditions but with no</span>
<span class="sd">                AO correction</span>
<span class="sd">            p.w = 0        no AO correction </span>
<span class="sd">            MTF2PSF, p, sz, psf2_noAO, psf1_noAO  </span>
<span class="sd">    </span>
<span class="sd">                compute the diffraction limited PSF</span>
<span class="sd">            MTF2PSF, p, sz, psf2_perf, psf1_perf, /perf</span>
<span class="sd">    </span>
<span class="sd">            There is a subtle difference between setting the /perf</span>
<span class="sd">            keyword to MTF2PSF and setting r0 to some extremely large</span>
<span class="sd">            and unphysical value to mimic diffraction limited seeing.</span>
<span class="sd">            The former computes the PSF from the pupil MTF, while the</span>
<span class="sd">            latter uses the product of the puipl MTF, the atmospheric/AO</span>
<span class="sd">            MTF (which is essentially unity) and the detector MTF.  The</span>
<span class="sd">            detector MTF is a broad sinc function, and its resulting</span>
<span class="sd">            effect on the PSF is small.  In other words, setting the</span>
<span class="sd">            /perf keyword fails to take into account the effect of the</span>
<span class="sd">            detector on the PSF.       </span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher Sheehy, January 2006.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">par</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">wave</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
    <span class="n">flen</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span>
    <span class="n">Apix</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;Apix&#39;</span><span class="p">]</span>

    <span class="n">platescale</span> <span class="o">=</span> <span class="p">(</span><span class="n">Apix</span> <span class="o">/</span> <span class="n">flen</span><span class="p">)</span> <span class="o">*</span> <span class="mf">206265.0</span>  <span class="c1"># detector scale in arcsec</span>
    <span class="n">xsamp</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># oversample PSF by a factor of 5</span>
    <span class="n">maxpix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">sz</span> <span class="o">/</span> <span class="n">platescale</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mf">5.0</span>

    <span class="n">nw</span> <span class="o">=</span> <span class="n">maxpix</span> <span class="o">*</span> <span class="n">xsamp</span> 
    <span class="n">pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">pix</span> <span class="o">*=</span> <span class="n">maxpix</span> <span class="o">/</span> <span class="n">nw</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">pix</span> <span class="o">*</span> <span class="n">platescale</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">((</span><span class="n">wave</span> <span class="o">/</span> <span class="n">D</span><span class="p">)</span> <span class="o">*</span> <span class="mf">206265.0</span><span class="p">)</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="mf">1000.0</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">/=</span> <span class="p">(</span><span class="n">nf</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pp</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pp</span><span class="p">[</span><span class="s1">&#39;cmult&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">perfect</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">mtffunc_keck</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;perfect&#39;</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">mtffunc_keck</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;system&#39;</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nw</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">T</span> <span class="o">*</span> <span class="n">special</span><span class="o">.</span><span class="n">jn</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
        <span class="n">psf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">integral</span>

    <span class="n">pix</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">wave</span><span class="o">/</span><span class="n">D</span><span class="p">)</span> <span class="o">*</span> <span class="mf">206265.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">platescale</span>
    <span class="n">szpix</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">sz</span> <span class="o">/</span> <span class="n">platescale</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">szpix</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">szpix</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">szpix</span><span class="p">,</span> <span class="n">szpix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">cent</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">szpix</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xx</span> <span class="o">-</span> <span class="n">cent</span><span class="p">,</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">cent</span><span class="p">)</span>

    <span class="n">rr</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    
    <span class="n">psfInterp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">pix</span><span class="p">,</span> <span class="n">psf</span><span class="p">)</span>
    <span class="n">psf2d_0</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">rr</span><span class="p">,</span> <span class="n">psfInterp</span><span class="p">)</span>
    
    <span class="n">psf2d</span> <span class="o">=</span> <span class="n">psf2d_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">szpix</span><span class="p">,</span> <span class="n">szpix</span><span class="p">))</span>
    <span class="n">psf1d</span> <span class="o">=</span> <span class="n">psf</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sz</span><span class="o">/</span><span class="n">platescale</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">*</span><span class="n">xsamp</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">psf2d</span><span class="p">,</span> <span class="n">psf1d</span></div>

<div class="viewcode-block" id="mtf2ee"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.mtf2ee">[docs]</a><span class="k">def</span> <span class="nf">mtf2ee</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">pixx</span><span class="p">,</span> <span class="n">perfect</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            MTF2EE</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Calculates the AO PSF&#39;s encircled energy curve from the AO</span>
<span class="sd">            corrected modulation transfer function.</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ???</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            MTF2EE, Params, Pix, EE</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            Params:  A structure of parameters, defined as in the</span>
<span class="sd">                     documentation for MTFFUNC_KECK.</span>
<span class="sd">            Pix:     A vector of radii, in pixels, at which the encircled</span>
<span class="sd">                     energy curve of growth is calculated.  The pixel</span>
<span class="sd">                     scale in pixels/arcsecond is calculated as</span>
<span class="sd">                     (Params.APIX / Params.F)*206265.</span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL INPUTS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            /Perf:  If this keyword is set, the returned curve of growth</span>
<span class="sd">                    is for the diffraction limited PSF as calculated from</span>
<span class="sd">                    the pupil MTF.</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            EE:  A vector of size equal to Pix     the curve of growth</span>
<span class="sd">                 evaluated at input Pix</span>
<span class="sd">    </span>
<span class="sd">     OPTIONAL OUTPUTS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE CALLS:</span>
<span class="sd">            MTFFUNC_KECK(), INT_TABULATED()</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE:</span>
<span class="sd">            For the given input parameters Params, the 1-D MTF is</span>
<span class="sd">            computed via the procedure MTFFUNC_KECK.  The encirled energy</span>
<span class="sd">            curve of growth is then given by the integral</span>
<span class="sd">                              1/</span>
<span class="sd">              EE(w) = (2*Pi*w) | MTF(nu) * BesselJ_1(2*PI*w*nu)* d nu,</span>
<span class="sd">                              0/</span>
<span class="sd">            where w is dimensionless angular distance from the PSF center</span>
<span class="sd">            in units of (lambda/D), and nu is normalized spatial</span>
<span class="sd">            frequency in the image plane.  </span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher D. Sheehy, January 2006.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">par</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>    <span class="c1"># prevent input params from begin altered at main level</span>
    <span class="n">wave</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;wave&#39;</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
    <span class="n">flen</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span>
    <span class="n">apix</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;Apix&#39;</span><span class="p">]</span>
    <span class="n">platescale</span> <span class="o">=</span> <span class="p">(</span><span class="n">apix</span> <span class="o">/</span> <span class="n">flen</span><span class="p">)</span>  <span class="c1"># detector platescale in radians/pixel</span>
    <span class="n">nw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pixx</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">pixx</span> <span class="o">*</span> <span class="n">platescale</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">wave</span> <span class="o">/</span> <span class="n">D</span><span class="p">)</span>
    
    <span class="c1"># set the frequency resolution of the MTF over which to integrate</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="mi">500</span>  
    <span class="n">vn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">vn</span> <span class="o">/=</span> <span class="n">npts</span> <span class="o">-</span> <span class="mf">1.0</span>

    <span class="n">p</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">p</span><span class="p">[</span><span class="s1">&#39;cmult&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    
    <span class="k">if</span> <span class="n">perfect</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">mtffunc_keck</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="n">vn</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;perfect&#39;</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">mtffunc_keck</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="n">vn</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;system&#39;</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">ee</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nw</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">T</span> <span class="o">*</span> <span class="n">special</span><span class="o">.</span><span class="n">jn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">vn</span><span class="p">)</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">vn</span><span class="p">)</span>
        <span class="n">ee</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">integral</span>

    <span class="k">return</span> <span class="n">ee</span></div>



<div class="viewcode-block" id="strehl"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.strehl">[docs]</a><span class="k">def</span> <span class="nf">strehl</span><span class="p">(</span><span class="n">par</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     NAME:</span>
<span class="sd">            STREHL</span>
<span class="sd">    </span>
<span class="sd">     PURPOSE:</span>
<span class="sd">            Computes the Strehl ratio of an AO PSF from its corresponding</span>
<span class="sd">            modulation transfer function (MTF).</span>
<span class="sd">    </span>
<span class="sd">     CATEGORY:</span>
<span class="sd">            ???</span>
<span class="sd">    </span>
<span class="sd">     CALLING SEQUENCE:</span>
<span class="sd">            sr = STREHL(params)</span>
<span class="sd">    </span>
<span class="sd">     INPUTS:</span>
<span class="sd">            Params:  A structure of parameters used to compute the AO</span>
<span class="sd">                     MTF, as defined in the documentation for</span>
<span class="sd">                     MTFFUNC_KECK. </span>
<span class="sd">    </span>
<span class="sd">     KEYWORD PARAMETERS:</span>
<span class="sd">            NONE</span>
<span class="sd">    </span>
<span class="sd">     OUTPUTS:</span>
<span class="sd">            The scalar strehl ratio for the given input parameters</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE CALLS:</span>
<span class="sd">            MTFFUNC_KECK(), INT_TABULATED()</span>
<span class="sd">    </span>
<span class="sd">     PROCEDURE:</span>
<span class="sd">            For the given input parameters, the MTF, T,  is calculated</span>
<span class="sd">            via MTFFUNC_KECK() along with the diffraction limited MTF,</span>
<span class="sd">            Tperf.  The strehl ratio, defined as the ratio of the height</span>
<span class="sd">            of the observed PSF to the diffraction limited PSF is</span>
<span class="sd">            calculated as (see documentation for MTF2PSF)</span>
<span class="sd">    </span>
<span class="sd">                   1/</span>
<span class="sd">                    | T(nu)*nu d nu</span>
<span class="sd">                   0/</span>
<span class="sd">            Sr = -------------------- .</span>
<span class="sd">                 1/</span>
<span class="sd">                  | Tperf(nu)*nu d nu</span>
<span class="sd">                 0/</span>
<span class="sd">    </span>
<span class="sd">     MODIFICATION HISTORY:</span>
<span class="sd">            Written by Christopher D. Sheehy, January 2006.</span>
<span class="sd">    &quot;&quot;&quot;</span>            

    <span class="n">npts</span> <span class="o">=</span> <span class="mf">500.0</span>
    <span class="n">vn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">vn</span> <span class="o">/=</span> <span class="p">(</span><span class="n">npts</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">par</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">p</span><span class="p">[</span><span class="s1">&#39;cmult&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">p</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># modified for fitting in log space</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">mtffunc_keck</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="n">vn</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">Tp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">mtffunc_keck</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="n">vn</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;perfect&#39;</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">sr</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="n">vn</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">vn</span><span class="p">)</span> <span class="o">/</span> <span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">Tp</span><span class="o">*</span><span class="n">vn</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">vn</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sr</span></div>


<div class="viewcode-block" id="DataHolder"><a class="viewcode-back" href="../../../autoapi/kai/mtf/mtf/index.html#kai.mtf.mtf.DataHolder">[docs]</a><span class="k">class</span> <span class="nc">DataHolder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, J. R. Lu, A. K. Gautam, T. Do.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>